{"pageProps":{"posts":{"data":[{"id":1,"attributes":{"title":"자바스크립트 this에 대해","content":"![this.png](https://cobb-dev-backend-u8nfg.ondigitalocean.app/uploads/this_88f5aa0e91.png)\n\n# this\nthis는 객체를 가르키는 자기 참조 변수입니다. this는 항상 **객체**를 가르킵니다.\n\n## this는 왜 필요할까요?\n자바스크립트에서는 this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조합니다.\n\n## this의 호출\nthis는 **호출에 따라** 참조하는 객체가 달라집니다.\n\n```js\n// 객체 프로퍼티를 직접 호출할 경우\n\nconst object = {\n\tname: 'cobb',\n  example: function(){\n\t\tconsole.log(this)\n\t}\n}\n\nobject.example(); // expected output : {name: 'cobb', example: ƒ}\n\n// 객체 프로퍼티를 직접 호출하지 않을 경우\n\nconst object = {\n\tname: 'cobb',\n  example: function(){\n\t\tconsole.log(this)\n\t}\n}\n\nconst notDirect = object.example;\n\nnotDirect();\n\n// expected output : Window {0: Window, 1: Window, window: Window, self: Window,\n// document: document, name: '', location: Location, …}\n```\n\n`window 객체`가 출력됩니다.\n\n```js\nnotDirect = object.example;\nnotDirect()\n```\n\n는 왜 window 객체를 출력할까요?\n\n\n## 전역스코프에서의 this\n전역스코프에서 this는 window 객체를 참조합니다.\n\nnotDirect는 전역 스코프에 object.example이 할당 됐으므로, notDirect는 object 객체가 아닌, window 객체를 호출하게 됩니다.\n\n## 화살표 함수에서 this는 어떻게 다른가요?\n화살표 함수가 등장하기 전까지는, 함수 선언식은 호출 방법에 따라 this의 값을 정의했습니다.\n\n하지만 **화살표 함수는 자신을 포함하고 있는 외부 스코프에서 this를 계승(물려)받습니다.**\n\n코드로 살펴보겠습니다.\n\n```js\n// 일반 함수\nconst person = {\n\tname: 'cobb',\n\tage: 26,\n\thello: function() {\n\t\tsetTimeout(function(){\n\t\t\t\tconsole.log(this)\n\t\t},1000)\n\t}\n}\n\nperson.hello(); // window 객체 출력 // ????? 왜 윈도우 객체를 출력하세요 ???\n\n\n// 화살표 함수\nconst person = {\n\tname: 'cobb',\n\tage: 26,\n\thello: function() {\n\t\tsetTimeout(() => {\n\t\t\t\tconsole.log(this)\n\t\t},1000)\n\t}\n}\n\nperson.hello(); // {name: 'cobb', age: 26, hello: ƒ} 출력\n```\n\n**어떻게 이런 일이 발생했을까요? (저도 글을 작성하다가 헷갈려서 다시 공부했습니다)**\n\n```js\n// 일반 함수\nconst person = {\n\tname: 'cobb',\n\tage: 26,\n\thello: function() {\n\t\tsetTimeout(function(){\n\t\t\t\tconsole.log(this)\n\t\t},1000)\n\t}\n}\n\nperson.hello(); // window 객체 출력\n```\n\n해당 코드는 왜 `person 객체`를 출력하지 않고, `window 객체`를 출력하는 걸까요?\n\n**정답은 setTimeout에 있습니다.**\n\nsetTimeout 함수에서 this가 호출 되었을 때 person 객체를 가르키는게 맞는 듯 보이지만, setTimeout에 인자로 들어가 비동기로 this가 호출되면서 this가 window 객체를 가르키게 됩니다.\n\n`비동기`로 호출되는 함수들은 호출되는 시점에 this가 window 객체를 가르킨다고 생각하면 됩니다.\n\n그 밑의 화살표 함수 예제를 살펴봅시다.\n\n```js\nconst person = {\n\tname: 'cobb',\n\tage: 26,\n\thello: function() {\n\n\t\tconsole.log(this). <-- 여기서 this는 `person object` 를 가르킵니다.\n\n\t\t↓ 상위 스코프에서 계승(물려줌)\n\n\t\tsetTimeout(() => {\n\t\t\t\tconsole.log(this) <-- this는 더이상 `window object`를 가르키지 않습니다.\n\t\t},1000)\n\t}\n}\n\nperson.hello(); // {name: 'cobb', age: 26, hello: ƒ} 출력\n```\n\n상기했듯이, 화살표 함수는 자신을 포함하고 있는 외부 스코프에서 this를 계승(물려)받습니다.\n\n그렇기 때문에 `hello: function() { // 여기 속한 this }`를 물려받게 됨으로, setTimeout 콜백 함수 안의 this는 더이상 window 객체를 가르키지 않고, person 객체를 가르키게 됩니다.\n\n###화살표 함수를 사용하면 안 되는 경우?\n\n```js\nconst person = {\n\tname: 'cobb',\n\tprint: () => {\n\t\tconsole.log(this) // window 객체 출력\n\t}\n}\n```\n\n해당 예제에서 this가 person 객체를 참조할 거 같지만 실제론 window 객체를 참조하게 됩니다.\n\nwindow 객체가 출력되는 이유는, 상기한 이유와 동일하게 화살표 함수는 this를 물려받습니다.\n\nperson 객체를 감싸고 있는 `스코프`는 무엇일까요?\n\n네. 전역 스코프입니다. 전역 스코프에서의 this는 window 객체를 가르킵니다.\n\n전역 스코프에서 person.print로 this가 계승됨으로, person.print()는 window 객체를 출력하게 됩니다.\n\n## 마지막으로, Strict Mode에서의 this\n엄격모드에서는 가르킬 객체가 없는 경우 기본값을 window로 하지 않고 undefined로 설정합니다.\n\n```js\n// None Strict Mode\n\nfunction printThis(){\n\tconsole.log(this)\n}\n\nprintThis(); // window 객체 출력\n\n\n// Strict Mode\n\nfunction printThis(){\n\tconsole.log(this)\n}\n\nprintThis(); // undefined\n```\n\nStrict Mode에서 printThis가 호출하는 this는 기본 값인 window 객체를 제외하고 **자신이 속한 객체를 찾을 수 없으니** undefined를 반환합니다.\n\n## 맺으며\n오늘은 this에 대해서 간단히 공부해봤습니다. this의 전부를 다루지는 않았고, 많은 use case를 공부해보진 않았지만 this의 개념에 관해선 간단히 정리가 되는 글이였으면 좋겠습니다.\n\n쓸 일이 많을까..? 하고 잊어버리기 십상이지만, 그래도 마음속에 잘 간직해놓고 두고두고 공부해봅시다.","subtitle":"React를 공부하면서 잊혀져가는 this, 그래도 공부해봅시다.","createdAt":"2022-11-21T09:39:06.327Z","updatedAt":"2022-11-21T10:07:11.001Z","publishedAt":"2022-11-21T09:39:09.369Z","thumbnail":{"data":{"id":4,"attributes":{"name":"javascript.png","alternativeText":null,"caption":null,"width":500,"height":300,"formats":{"thumbnail":{"ext":".png","url":"/uploads/thumbnail_javascript_d5e1b2cbfb.png","hash":"thumbnail_javascript_d5e1b2cbfb","mime":"image/png","name":"thumbnail_javascript.png","path":null,"size":7.59,"width":245,"height":147}},"hash":"javascript_d5e1b2cbfb","ext":".png","mime":"image/png","size":10.54,"url":"/uploads/javascript_d5e1b2cbfb.png","previewUrl":null,"provider":"local","provider_metadata":null,"createdAt":"2022-11-21T09:38:48.983Z","updatedAt":"2022-11-21T09:38:48.983Z"}}},"tag":{"data":{"id":2,"attributes":{"tag":"JavaScript","createdAt":"2022-11-21T09:37:13.012Z","updatedAt":"2022-11-21T09:37:42.502Z","publishedAt":"2022-11-21T09:37:42.498Z"}}}}},{"id":2,"attributes":{"title":"새로운 패러다임, 함수형 프로그래밍","content":"![functionalprogramming.png](https://cobb-dev-backend-u8nfg.ondigitalocean.app/uploads/functionalprogramming_666eb25bb1.png)\n\n# 함수형 프로그래밍\n\n함수형 프로그래밍은 프로그래밍 분야의 패러다임이자 패턴입니다. 상태와 가변 데이터를 멀리하는 프로그래밍 방법론입니다. 부수 효과(Side Effect)가 없으면 프로그램의 동작의 이해와 예측이 쉬워지기 때문에 **부수 효과가 없는 순수 함수로 작성합니다.**\n\n간단히 요약하자면 순수 함수의 조합으로 유지보수가 쉬운 코드를 작성하는 방법론입니다.\n\n## 함수형 프로그래밍의 특징\n\n1. 순수함수\n2. 불변성\n3. 선언적 패턴\n\n## 순수 함수?\n순수 함수란 동일한 인자가 전달되면 동일한 결과를 반환하는 함수입니다. 이렇게 동일한 결과를 반환하는 함수는 부수 효과가 없음을 의미하기도 합니다. 인자가 같으면 항상 결과값이 같은 함수니까요.\n\n코드로 보겠습니다.\n\n```js\n// 순수함수\n\nfunction plus(num1, num2) {\n  return number1 + number2;\n};\n```\n위의 함수는 동일한 인자값일 때 항상 동일한 결과값이 나오게 됩니다. 순수 함수의 가장 간단한 예시입니다.\n\n그렇다면 순수하지 않은 함수의 예제를 보겠습니다.\n\n```js\nlet externalNum = 10;\n\nfunction plus(num1, num2) {\n  return number1 + number2 + otherNumber;\n};\n\nconsole.log(plus(1, 1)); // 12\nconsole.log(plus(1, 1)); // 12\n\nexternalNum = 15; // 재할당\n\nconsole.log(plus(1, 1)); // 17\nconsole.log(plus(1, 1)); // 17\n```\n지금 정의한 `plus 함수`는 외부에 정의된 `otherNumber` 를 num1 + num2에 더해서 반환합니다. 이런 형태로 `함수 바깥에서 선언된` 변수가 함수 안에서 사용된다면, 외부 함수가 재할당 됐을 때 함수는 결과값이 달라지기 때문에 순수 함수라고 할 수 없습니다\n\n### 순수 함수가 가지는 장점\n외부에 선언된 변수나 함수에 영향을 받지 않기 때문에, 실행 시점에 구애를 받지 않습니다. 언제, 어디든 똑같은 값을 반환하기 때문입니다.\n\n순수하지 않은 함수는 외부에 선언된 변수나 함수에 영향을 받기 때문에 개발자가 의도한 결과값과 다른 값을 반환할 수 있게 되고, 그로 인해 유지보수의 난이도가 올라가게 됩니다.\n\n함수의 조합도 용이해집니다. 순수 함수는 예측 가능한 결과를 내기 때문입니다. 비순수 함수를 조합하게 되면 언제 어디서든 외부 요인에 영향을 받을 수 있기 때문에 디버깅이 어려워집니다.\n\n## 불변성(immutability)\n간단하게 정의하자면 **`상태를 변경하지 않는 것`** 입니다.'\n\n이해를 돕기 위해 간단한 코드로 먼저 살펴보겠습니다.\n\n```js\nlet user = {\n  name: 'cobb',\n  age: 26\n};\n\nfunction changeAge(user) {\n  user.age = user.age + 1;\n  \n  return user;\n}\n```\n해당 코드에서는 `changeAge` 함수에서 user 객체의 `age` 속성값을 변경합니다. 이는 **불변성을 충족시키지 못하는 코드**가 됩니다.\n\n그럼, 불변성을 충족시킬 수 있는 코드로 바꿔보겠습니다.\n\n```js\nlet user = {\n  name: 'cobb',\n  age: 26\n};\n\nfunction changeAge(user) {\n   return {...user, age: user.age + 1};\n}\n\n// console.log(changeAge(user)); // {name: 'cobb', age: 27}\n// console.log(user); // {name: 'cobb', age: 26}\n```\n원본 객체인 user가 변경되지 않았습니다. 데이터의 복사본을 만들어(`{...user}`) 해당 복사본을 사용해 원하는 동작을 실행하고, 복사본을 반환합니다.\n\n### 원본 데이터를 보존함으로 얻는 장점\n\n무불별한 상태 변경을 막을 수 있습니다. 개발은 단독으로 진행하지 않습니다. 특정 다수가 무분별하게 원본을 참조하거나 변경하게 되면 혼란이 생길 수밖에 없습니다.\n\n> \"내가 참조하려고 했던 상태가 이거였다고?\"\n\n라는 말이 나올 수 있는 거죠. 그러므로 원본에 대한 규제를 거는 겁니다.\n\n> \"원본은 유지하되, 원본을 참조하고 싶은 분은 복사본을 만들어서 작업해주세요.\"\n\n이렇게 원본를 유지하게 되면 전역 변수의 남용을 막을 수 있게 되고, 순수 함수 조합으로 프로그래밍하기 적절한 환경이 조성됩니다.\n\n## 선언적 패턴(declarative pattern)\n\n먼저 명령형 프로그래밍과, 선언형 프로그래밍의 차이를 알아보겠습니다.\n\n> 명령형 프로그래밍은 무엇을 **어떻게 할 것인가**에 가깝고, 선언형 프로그래밍은 **무엇을 할 것인가**와 가깝다.\n\n예시와 코드로 정리해보겠습니다.\n\n예를 들어 우리가 ` 'Hello my name is Cobb' ` 이라는 `문자열`을 갖고 있습니다. 이 문자열에서 공백을 제거하고, 그 공백을 `$`으로 대체하는 함수를 만들고 싶습니다.\n\n명령형 코드에서는,\n\n```js\nfunction spaceToDollar(string) {\n\n  let result = '';\n  \n  for (let i=0; i<string.length; i++) {\n    if(text[i] === \" \") {\n      result += \"$\"\n    } else {\n      result += text[i];\n    }\n  }\n  \n  return result;\n}\n```\n보기만 해도 숨막히지 않나요? 요구사항을 충족하는데 필요한 모든 단계를 코드로 작성하고 있습니다. 무엇을 `어떻게 할 것인가` 를 전부 코드로 작성하고 있는 것이죠.\n\n그럼 선언형 코드를 한번 살펴보겠습니다.\n\n```js\nfunction spaceToDollar(string) {\n  return string.replaceAll(\" \", \"$\");\n}\n```\n\n같은 역할을 하는 함수지만, 가독성이 압도적으로 좋습니다.\n\n다만 알아야 할 것은 `replaceAll()`함수 내부에서는 우리가 명령형 코드로 작성한 코드로 동작할 수 있습니다. 명령형 코드가 추상화되어 선언형 패턴을 사용할 수 있게 됐습니다. 고로 좋고 나쁘고의 관점이 아닌, 유지보수와 디버깅이 관건입니다.\n\n개발자 입장에서는 모든 동작을 코드를 보고 이해하는 것보다, 추상화한 함수를 보고 동작을 이해하는게 훨씬 편합니다. `프로그램의 동작과 예측, 이해가 쉬워지는` 함수형 프로그래밍과 딱 맞는 패턴이 선언적 패턴인 겁니다.\n\n## 맺으며\n\n오늘은 함수형 프로그래밍을 공부해봤는데, OOP보다 진입장벽이 낮고, 개발자의 생산성을 올려주는 패러다임이라고 생각합니다. 제가 OOP에 익숙하지 않아서 그런 걸 수도 있지만.. 리액트하다가 OOP를 보면 살짝 어지러운 느낌이..\n\n또 개발자의 편의를 극대화한 패러다임이 빠른 시간 내에 등장할 거라고 믿습니다. 더 용이하고 더 빠르고 더 안전한 코딩 패러다임의 등장을 기대해봅니다.","subtitle":"함수형 프로그래밍? 명령형 프로그래밍? 선언형 프로그래밍? 헷갈리지 말자!","createdAt":"2022-11-21T10:00:14.014Z","updatedAt":"2022-11-22T08:17:05.325Z","publishedAt":"2022-11-21T10:00:16.160Z","thumbnail":{"data":{"id":4,"attributes":{"name":"javascript.png","alternativeText":null,"caption":null,"width":500,"height":300,"formats":{"thumbnail":{"ext":".png","url":"/uploads/thumbnail_javascript_d5e1b2cbfb.png","hash":"thumbnail_javascript_d5e1b2cbfb","mime":"image/png","name":"thumbnail_javascript.png","path":null,"size":7.59,"width":245,"height":147}},"hash":"javascript_d5e1b2cbfb","ext":".png","mime":"image/png","size":10.54,"url":"/uploads/javascript_d5e1b2cbfb.png","previewUrl":null,"provider":"local","provider_metadata":null,"createdAt":"2022-11-21T09:38:48.983Z","updatedAt":"2022-11-21T09:38:48.983Z"}}},"tag":{"data":{"id":2,"attributes":{"tag":"JavaScript","createdAt":"2022-11-21T09:37:13.012Z","updatedAt":"2022-11-21T09:37:42.502Z","publishedAt":"2022-11-21T09:37:42.498Z"}}}}},{"id":4,"attributes":{"title":"자바스크립트 변수명과 성능","content":"![Variables.png](https://cobb-dev-backend-u8nfg.ondigitalocean.app/uploads/Variables_37c183953e.png)\n\n## 자바스크립트 변수명과 성능에 관해서\n\n## 이 고민을 하게 된 계기\n\n> 팀원들과 협업 중, 전부 코드 스타일이 달랐지만 ESLint와 Prettier의 도움으로 코드 컨벤션을 최대한 통일할 수 있었습니다. 하지만 리팩토링 과정에서 팀원에게 권유를 받았습니다.\n\n> 코브님, 변수명을 조금 더 짧게 쓰는 건 어떨까요?\n\n해당 협업을 진행하기 전, 저는 혼자 공부하고, 혼자 프론트를 맡은 일이 많았기 때문에, 변수명과 함수명에 대해서 크게 신경쓰지 않았습니다.\n\n변수명, 함수명을 봐도 어떤 값이 할당되어있는지, 어떤 동작이 함수안에서 일어나는지 알 수 없었습니다. 직관적이지 않은, 그때그때 급조한 변수명 함수명을 써왔습니다.\n\n그래서 새로운 프로젝트를 시작할 때 직관적인 변수명과 함수명을 짓기로 마음먹었습니다. 하지만 그러자마자 팀원의 권유를 듣고, 제가 잘못된 방식을 채택했나 고민했습니다.\n\n문제의 변수명은 이것이었다.\n\n```js\nconst getSearchTextAndReturnArray = (value: string) => {\n\tconst changeValueToArray = value.split('')\n    \n\tconst arrayWithNoEmptyString = changeValueToArray.filter((element) => element !== ' ')\n\n\treturn arrayWithNoEmptyString\n}\n\ngetSearchTextAndReturnArray('Hello my name is Cobb')\n\n// expected output \n// ['H', 'e', 'l', 'l', 'o', 'm', 'y', 'n', 'a', 'm', 'e', 'i', 's', 'C', 'o', 'b', 'b']\n```\n해당 코드는 퍼지 문자열 검색에 사용했던 것 같습니다.\n\n변수 식별자가 굉장히 길죠? `getSearchTextAndReturnArray`로 무려 27자입니다. 해당 함수 스코프 내부의 식별자도 살펴보겠습니다.\n\n`changeValueToArray` 는 `string`을 `array`로 바꾸는 `split 메서드`를 사용해 배열을 반환하고,\n\n`arrayWithNoEmptyString` 은 배열에 `empty string(’ ’)`이 있으면 제거하고 다시 배열을 반환합니다.\n\n식별자를 통해 해당 함수와 변수가 `무엇을 실행하나`를 알 수 있습니다. (개인적인 의견일 수도 있습니다.)\n\n### 팀원의 권유를 듣고\n\n> 굳이 변수명을 줄일 필요가 있나? 오히려 변수명을 확실히하는 게 클린코드에 더 가까워지는 방법 아닐까?\n\n생각했습니다.\n\n## 변수명의 물리적인 길이 제한?\n\n**변수명의 길이 제한은 없다.**\n\n159,000자를 넘어 갈 때 웹 구동이 불가능 할 정도로 느려진다고 합니다.\n그러므로 일반적인 상황에선 제한이 없다고 생각하면 됩니다.\n\n## 변수명이 길어지면 성능에 영향이 생긴다?\n\n> It causes a negligibly small performance difference in practise, but only when declaring the variable. Afterwards, it gets a specific address in the memory, and it is referred as this address, not the variable name, so it won't affect the performance anymore.\n> \n> 실제론 영향이 거의 없습니다. 다만 변수를 선언할 때는 영향이 있을 수 있습니다. 후에 변수를 참조할 경우 메모리 주소를 참조하기 때문에, 변수명은 더이상 퍼포먼스에 영향을 끼치지 않습니다.\n\n> However, talking about a scripting language used mostly on web, shorter variable names can reduce the filesize, and speed up pageloads. This is one of the features of the JS compilers, such as Google's.\n> \n> 그러나 웹에 사용되는 스크립트 언어의 특성상 짧은 변수명은 파일 사이즈를 줄여주고, 더 빠르게 페이지를 로드합니다. 이는 JS 컴파일러의 특징입니다.\n\n### 결론\n변수명이 길어진다고 해서 성능에 영향을 끼치지 않는다 (정말 근소한 퍼포먼스 오차).\n짧은 변수명은 파일 사이즈를 줄여준다. 다만 특별히 길지 않은 변수명이 아니라면, 신경쓰지 않아도 된다.\n\n라고 결론지을 수 있습니다.\n\n## 그럼, 클린코드 관점에서는 어떻게 접근해야할까?\n\n> In general, here are rules JavaScript has for naming variables:\n> \n> - The first character must be a letter or an underscore (_). You can’t use a number as the first character.\n> \n> - In JavaScript, variable names are case sensitive. That is, a variable named `firstName` is treated as an entirely different variable than one named `firstname`.\n> \n> - There’s no limit to the length of the variable name. But who would want to deal with variable `highNetWorthAccountsBrokenDownByCountryInAsia`?\n> \n> - You can’t use one of JavaScript’s reserved words as a variable name.\n\n> 보편적으로 따르는 자바스크립트 variables naming convention 입니다.\n> \n> - 가장 첫 번째 글자는 문자나 언더스코어(_)여야 합니다. 첫 번째 문자로 숫자를 써선 안 됩니다.\n> \n> - 자바스크립트에서 변수명은 대/소 문자에 민감합니다. `firstName`과 `firstname`으로 선언한각각의 변수는 다르게 취급됩니다.\n> \n> - 변수명 길이 제한은 없습니다. 근데 누가 `헤더컴포넌트에사용될메뉴컴포넌트입니다`를 사용하고 싶어할까요?\n> \n> - 자바스크립트 예약어는 사용할 수 없습니다.\n\n> Ideas for Good Variable Names\n> \n> A JavaScript variable should be self-descriptive. It shouldn’t be necessary to add a comment just to what the variable is. Use meaningful names and be as concise as possible.\n\n> 좋은 변수명을 만드는 방법\n> \n> 자바스크립트의 변수는 자기표현적이어야 합니다. 이 변수가 어떤 동작을 하는지 별도로 말하지 않아도 되게끔 말입니다. 의미있는(표현적인) 변수명을 쓰되, 최대한 간결하게 작성하세요.\n\n```\n좋은 방법                          나쁜 방법 (모호함)\n======================================\n getUserPosts               getUserData, getUserInfo\n getActiveCustomer     getCustomer\n findUserByName         findUser\n```\n\n```js\nconst getSearchTextAndReturnArray = (value: string) => {\n\tconst changeValueToArray = value.split('')\n    \n\tconst arrayWithNoEmptyString = changeValueToArray.filter((element) => element !== ' ')\n\n\treturn arrayWithNoEmptyString\n}\n```\n해당 코드는 충분히 표현적입니다. 하지만 concise하지 않습니다. bad practice라고 생각해도 되는 거죠. 제게 리팩토링을 권유한 동료 프론트엔드 개발자도 아마 이 부분을 지적한 것 같습니다.\n\n그럼, 이 변수명을 어떻게 리팩토링 할 수 있을까?\n\n```js\nconst removeBlank = (value: string) => {\n\tconst stringToArr = value.split('')\n    \n\tconst onlyStringArr = stringToArr.filter((element) => element !== ' ')\n\n\treturn onlyString\n}\n```\n이렇게 하면 조금 더 깔끔해진 것 같지 않나요?\n\n## 맺으며\n역시 협업이 최고입니다.\n당연하게 생각하고 있던 것들도 다시 돌아보고, 더 나은 개발자가 될 수 있는 인사이트를 얻고 배울 수 있는 기회가 혼자 공부할 때보다 훨~씬 많은 거 같아요.\n\n더 나은 방법이 있으면 댓글로 알려주세요! 방문자님들의 멋진 인사이트도 참고하고싶습니다. 감사합니다.","subtitle":"변수명이 길어지면 퍼포먼스에 영향을 미칠 수 있을까?","createdAt":"2022-11-30T08:10:23.576Z","updatedAt":"2022-11-30T08:14:39.735Z","publishedAt":"2022-11-30T08:14:39.730Z","thumbnail":{"data":{"id":4,"attributes":{"name":"javascript.png","alternativeText":null,"caption":null,"width":500,"height":300,"formats":{"thumbnail":{"ext":".png","url":"/uploads/thumbnail_javascript_d5e1b2cbfb.png","hash":"thumbnail_javascript_d5e1b2cbfb","mime":"image/png","name":"thumbnail_javascript.png","path":null,"size":7.59,"width":245,"height":147}},"hash":"javascript_d5e1b2cbfb","ext":".png","mime":"image/png","size":10.54,"url":"/uploads/javascript_d5e1b2cbfb.png","previewUrl":null,"provider":"local","provider_metadata":null,"createdAt":"2022-11-21T09:38:48.983Z","updatedAt":"2022-11-21T09:38:48.983Z"}}},"tag":{"data":{"id":2,"attributes":{"tag":"JavaScript","createdAt":"2022-11-21T09:37:13.012Z","updatedAt":"2022-11-21T09:37:42.502Z","publishedAt":"2022-11-21T09:37:42.498Z"}}}}},{"id":3,"attributes":{"title":"자바스크립트 클로저","content":"![Closure.png](https://cobb-dev-backend-u8nfg.ondigitalocean.app/uploads/Closure_064a6eacfc.png)\n\n# Closure ( 클로저 )\n\n## 클로저란?\n\n함수와 함수가 선언된 환경의 관계입니다 (자신이 선언될 때의 환경을 기억하는 함수). Closure는 `폐쇄`를 의미합니다. 그럼 설명을 통해 왜 Closure가 Closure(폐쇄)로 불리는지 알아보겠습니다.\n\n## 클로저를 사용하는 이유?\n\n스코프를 이용해서 접근할 수 없는 환경을 만들 때 사용합니다.\n\n그럼, 코드를 통해 예시를 보겠습니다.\n\n```js\n// 클로저를 만드는 형태\n\nfunction outerFn() {\n  let x = 10;\n\n  return function innerFn(y) { \n    return x = x + y;\n  }\n}\n\nlet a = outerFn(); \n\nconsole.log(a(5)) // 15\nconsole.log(a(5)) // 20\n```\n\n이 코드는 어떻게 클로저 형태를 만들까요? `let a = outerFn();` 코드를 보겠습니다.\n\n변수 `a`는 `outerFn()`을 할당받았습니다. `outerFn()`은 `innerFn()`을 반환합니다. 그럼 `innerFn()`은 무슨 동작을 할까요?\n\n`x`를 외부 스코프에서 받고, `x`의 값을 `x + y`의 값으로 할당합니다.\n\n> `outerFn()`이 `arugument(인자)`를 받지 않습니다. 원래라면 `outerFn(y)`로 작성해야 되는 게 아닌가요?\n\n라고 생각하실 수 있습니다.\n\n`console.log(a(5))`가 가능한 이유는 `변수 a`가 `outerFn()`을 할당받았고, `outerFn()`의 `리턴 값`은 `innerFy()`이기 때문입니다. 그래서 `innerFy(y)`로 인자를 전달해줄 수 있게 됩니다.\n\n이런 형태의 함수를 봤을 때, 외부 스코프에서 `outerFn()` 스코프 안에 있는 `x`의 값에 접근해 값을 조작할 수 있을까요?\n\n**없습니다.** 이게 클로저의 한 형태입니다. `x`에 접근할 수 없는 환경을 만들고, `x`값을 은닉시키고 재사용할 수 있게 만드는 거죠.\n\n### 또 하나 알아야 할 게 있습니다.\n\n```js\nconsole.log(a(5)) // 15\nconsole.log(a(5)) // 20\n```\n\n어떻게 같은 `15`라는 같은 결과가 나오지 않고, 두 번째 호출했을 땐 `15`에서 `5`를 더한 20이 나오게 됐을 까요?\n\n원래라면 함수가 실행되고 종료되면 변수가 초기값인 `10`으로 초기화 되어 두 번째 호출시에도 `15`가 출력돼야 할 것 같은데 말입니다.\n\n마치 react에서 `setState((prev) => prev + 5)` 와 같은 코드처럼 작동하고 있습니다.\n\n이렇게 x값이 누적될 수 있는 이유는 바로\n\n`let a = outerFn();` 로 작성된 코드 때문입니다.\n\n최상위 스코프에서 `outerFn()`을 계속 `변수 a`가 할당받고 있는 형태입니다.\n\n그렇기 때문에 함수 호출이 끝나도 a가 메모리에서 제거되지 않습니다.\n\n클로저를 이해하기 위해선 가비지 컬렉션에 대한 약간의 이해가 필요합니다.\n\n## 가비지 컬렉션\n\n함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거됩니다.\n\n> 가바지 컬렉터: 이거 실행 했으니까 이제 필요없죠?? 메모리 낭비니까 가져다가 버립니다??\n\n**자바스크립트에서 모든 객체는 도달 가능한 상태일 때만 메모리에 유지됩니다.**\n\n(위의 예제는 `let a = outerFn()` 이 `outerFn()` 을 항상 도달 가능한 상태로 만듭니다.)\n\n```jsx\n// 위 예제와 똑같은 형태지만, 도달이 불가능한 객체 설명을 위한 코드블록.\n\nfunction f() {\n  let value = 123;\n\n  return function() {\n    alert(value);\n  }\n}\n\nlet g = f();\n// g가 f()를 계속 참조하기 때문에 메모리에 유지됩니다.\n\ng = null;\n// g가 더이상 함수를 참조하지 않기 때문에 f()는 메모리에서 삭제됩니다.\n```\n\n## 클로저 장점\n\n데이터 보존이 가능합니다.\n\n첫 번째 `console.log(a(5))` 가 끝나도 `let a` 가 할당받은 `outerFn()` ===  `innerFn(y)` 이 외부 스코프에 있는 `x` 를 참조하고 있기 때문에 함수 실행이 종료되도 `x` 는 초기값인 `10` 으로 돌아오지 않는다.\n\n정보 접근을 제한할 수 있습니다.\n\n참조할 수 없는 변수(위의 예제에서는 `let x = 10` 으로 선언된 `x의 값` )를 사용해 클로저를 이용한 제한적 접근을 제외한 모든 경우의 수를 차단할 수 있다. 이 과정을 `은닉화`라고 표현합니다.\n\n## 우리가 자주 사용하는 useState의 원리도 클로저\n\n```js\nfunction counter() {\n\tlet num = 0;\n\n\treturn function() {\n\t\treturn num++\n\t}\n}\n\nconst increase = counter()\n\nconsole.log(increase()) // 1\nconsole.log(increase()) // 2\nconsole.log(increase()) // 3\n\n===>\n\nconst [num, setNum] = useState(0);\n\nconsole.log(num) // 0, 1, 2, 3\n\n() => { setState((prev) => prev + 1) } // 한번 실행\n() => { setState((prev) => prev + 1) } // 두번 실행\n() => { setState((prev) => prev + 1) } // 세번 실행\n```\n\n## 맺으며\n클로저는 역시 어렵습니다. 자주 사용하게 되는 개념일까..? 생각해도 아닌 것 같고.. 그렇다고 모르면 또 안 될 거 같은 개념이네요 ㅎㅎ 클로저 같은 헷갈리는 개념을 이해할 땐 저처럼 직접 설명하듯 작성하는게 최고라는 생각이 드네요.\n\n나중에 프로덕션 레벨에서 일할땐 정보의 은닉화가 중요할 때가 분명 있을 것 같단 생각이 듭니다. 지금 잘 배워서 나중에 중요한 변수 꼼꼼히 숨겨놓아야겠습니다!","subtitle":"클로저, 폐쇄적이고 안전환 환경에서 코딩할 수 있는 좋은 방법!","createdAt":"2022-11-22T09:26:56.944Z","updatedAt":"2022-11-30T08:24:37.117Z","publishedAt":"2022-11-22T09:27:03.353Z","thumbnail":{"data":{"id":4,"attributes":{"name":"javascript.png","alternativeText":null,"caption":null,"width":500,"height":300,"formats":{"thumbnail":{"ext":".png","url":"/uploads/thumbnail_javascript_d5e1b2cbfb.png","hash":"thumbnail_javascript_d5e1b2cbfb","mime":"image/png","name":"thumbnail_javascript.png","path":null,"size":7.59,"width":245,"height":147}},"hash":"javascript_d5e1b2cbfb","ext":".png","mime":"image/png","size":10.54,"url":"/uploads/javascript_d5e1b2cbfb.png","previewUrl":null,"provider":"local","provider_metadata":null,"createdAt":"2022-11-21T09:38:48.983Z","updatedAt":"2022-11-21T09:38:48.983Z"}}},"tag":{"data":{"id":2,"attributes":{"tag":"JavaScript","createdAt":"2022-11-21T09:37:13.012Z","updatedAt":"2022-11-21T09:37:42.502Z","publishedAt":"2022-11-21T09:37:42.498Z"}}}}}],"meta":{"pagination":{"page":1,"pageSize":25,"pageCount":1,"total":4}}}},"__N_SSG":true}